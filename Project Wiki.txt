PROJECT WIKI

08/Outubro a 14/Outubro:
    - Leitura da documentação

04/Novembro a 11/Novembro:
    - Desenvolvimento do OFDM receiver no GNURadio
    - Implementação dos blocos da biblioteca gr-ieee802-11 (github)

12/Novembro a 19/Novembro:
	- Análise dos tópicos propostos para a semana 1 e 2
	- Resposta às questões das semanas 1 e 2 (verificar respostas abaixo)
	
20/Novembro a 26/Novembro:
	-
	





Week 1 topics:
	Lookup the 802.11a OFDM system design parameters
	■ Bandwidth, sub-carrier spacing, number of sub-carriers, IFFT/ FFT size, number of data sub-carriers, number of pilot sub-carriers:
		- Bandwidth: ieee802-11 supports signals with a bandwidth of 20MHz
		- Sub-carrier spacing: derived from the bandwith and FFT size => 20Mhz/64 = 312.5kHz
		- Sampling rate: 20Msamples/s
		- IFFT/FFT size: 64
		- Nº data sub-carriers: 48 (FFT-Pilot-DC-guard = 64-4-1-11 = 48)
		- Nº pilot sub-carriers: 4 

	■ Why are there unused sub-carriers and where are they located?
		- No sub-carriers are unsused, they are just unsused for data specificaly; Given that the sub-carriers that aren't used for data are the DC and Guard sub-carriers, for a total of 1+11=12 sub-carriers
	
	
	■ OFDM symbol duration, sampling rate, OFDM symbol length (samples), cyclic prefix length
		- Symbol duration: (80 samples) / (20Msamples/s) = 4us
		- Sampling rate: 1/4us = 250Ksymbols/s
		- Symbol length: 80 samples (64 data + 16 cyclic prefix)
		- cyclic prefix length: 16 samples
	
	
	■ Frame prefix sequence, length, repetition, duration
		○ Read section 2.1 and understand what it means
			- Section 2.1 outlines the structure of the OFDM Receiver: Frame detection and Frame decoding. As for the frame prefix, it's used a short training sequence with 16 samples that repeats a total of 10 times. The total duration is 8us => (16 samples * 10 repetitions) / (20MHz sampling rate) = 8us
			
	■ Where are the mentioned tags?
		○ Work yourself through Section 2.2
			- The tags are used to define the beggining of the sample; The tags are also used on de decoding stage to annotate legth and encoding scheme of the frame
		
	■ Identify the blocks that calculate the autocorrelation
		- The autocorrelation equation is defined by a[n]=∑s[n+k]s'[n+k+16]; The blocks used for the autocorrelation are the ones present on the top half of the filter: delay (16), complex conjugate (s'), multiply, decimating FIR filter (moving average) - summation -  and complex to mag (preforms absolute value)
	
	■ Identify the blocks that calculate the power
		- The power equation is defined by p[n]=∑∣s[n+k]∣^2; The blocks used to calculate power are complex to mag^2 (s^2), decimating FIR filter (Moving Average)- summation-  and divide block (to get c(n))
	
	■ Explore the effect of varying NWin, e.g. in the graph like Figure 2
		- Increasing Nwin​: Results in stronger low-pass filtering. The autocorrelation graph is smoother and less afected by noise, but it blurs the "plateau" edges, making the exact start detection less sharp.
		- Decreasing Nwin​: Reduces filtering, making the output more responsive to changes but also noisier.

Week 2
	■ Understand the OFDM Sync Short block
		○ What does the block do
			- The block functions as a gate for the data stream; Inputs: samples from the USRP and the calculated normalized autocorrelation coefficient; Output: If a frame is detected: It opens the gate and copies a fixed number of samples (corresponding to the maximum frame length) to the subsequent processing blocks, if no frame is detected it drops the samples, preventing noise from consuming processing power; Operation: It monitors the autocorrelation stream to detect the "plateau"
		
		○ What is the meaning of the thresholds
			- Used to distinguish between noise and actual wanted data; The threshold defines the minimum magnitude required for the normalized autocorrelation coefficient to be considered part of a preamble (training sequence) and minimum "plateau" (number of consecutive samples) to confirm a detection

		○ Explore the effect of changing the thresholds
		○ Understand the limitations of the approach taken, and try to demonstrate a case where it breaks



WEEK 3

Understanding the OFDM Sync Long block:
The OFDM Sync Long block performs two main operations: correcting frequency offset and aligning OFDM symbols. Frequency offset correction is based on the short training sequence. In an ideal OFDM signal, samples spaced 16 positions apart should match because the short training sequence repeats every 16 samples. If there is frequency offset, multiplying s[n] by s[n+16] gives a complex value with a phase rotation. The receiver sums these products and estimates the offset as:

df = (1/16) * arg(sum of s[n] * s[n+16])

Each sample is then corrected by multiplying by exp(i * n * df).
The same block also determines the exact start of the first data symbol, using the long training sequence for precise alignment.

Where is the offset correction implemented?
It is implemented inside OFDM Sync Long as described in Section 2.3 of the paper.

Which parameters could be changed?
The parameters that conceptually could change include the number of samples used in the accumulation (Nshort), the duration of the averaging window, and the behavior of the correction exponent. However, these are mathematical tuning parameters, not usually user-facing options.

Why is there a delayed input?
The algorithm needs to compare s[n] with s[n+16], so one version of the signal is delayed by 16 samples. This number comes from the IEEE 802.11 preamble design.

Could that value be changed and what would be the impact?
No. The value 16 comes from the OFDM short training sequence repeating every 16 samples. Changing it would break the assumption used for autocorrelation, meaning the frequency offset estimate would become invalid and synchronization would likely fail.

WEEK 4

How is symbol alignment performed?
Symbol alignment is done using matched filtering with the long training sequence, which is 64 samples long and repeats 2.5 times. The receiver computes the correlation between the incoming samples and the known training sequence:

sum(s[n+k] * LT[k]) for k from 0 to 63

It records the three largest correlation peaks and determines the beginning of the first data symbol using:

nP = max(peak positions) + 64

This +64 accounts for the distance between the final peak and the start of the first OFDM data symbol. After this, the cyclic prefix (16 samples) is removed and each symbol is passed as a block to the FFT.

Why is matched filtering used for symbol alignment but not for frame detection?
Frame detection needs to run continuously over the full signal stream in real time, so autocorrelation (which is cheaper computationally) is used. Symbol alignment only needs to run over a small portion of the data (the preamble), so matched filtering can be used to get much more precise timing.

What does the stream to vector block do?
It converts the continuous sample stream into fixed-size vectors (e.g., 64 samples per block), which are required for performing the FFT on each OFDM symbol.

Why do you add 64 in expression 7?
Because the dominant peak found corresponds to a point 64 samples before the end of the long training sequence. Adding 64 moves the index to where the first OFDM data symbol begins.

WEEK 5

Why do we need to correct the phase?
Even with time synchronization, small differences in the sender and receiver timing introduce a phase rotation that increases with subcarrier index. If not corrected, the constellation rotates, and correct demodulation becomes impossible.

Where is the code that estimates the phase offset?
The estimation is done in the OFDM Equalize Symbols block after the FFT. IEEE 802.11 includes four pilot subcarriers with known BPSK values. Their phase is used to estimate the linear phase trend using regression, based on the symbol index indicated earlier by OFDM Sync Long.

How is the phase corrected and what changing values are involved?
The estimated phase offset is subtracted from each subcarrier in the symbol. The complex samples in the frequency domain have their phase corrected. Magnitude is not changed except when performing channel equalization, which is a separate step.

Week 6
■ Understand the OFDM Equalize Symbols module
○What does it do?
○ Why is the implementation limited to deal with BPSK and QPSK
modulation?
○ Which other functions are performed in this block?
■ Work through Section 2.7
○ Look up the frame format for 802.x frames and how the data in the initial fields is transmitted. You are already looking into the MAC layer.
•	Recall what you learned in Computer Networks course about framing. How can you delimit a frame?
○ What is the Signal Field? Which information is sent there? Why is this information necessary?
○ How is that information encoded?

Week 7
■ Work through decoding the payload (Section 2.8)
○ Which abstract receiver blocks are within the module OFDM Decode Mac?
○ How many constellation symbols are demodulated at once? Why? Can you change this? What is the impact of changing this?
•	What is the actual process of digital demodulation? What is the input and the output, and how is the conversion done? Look at the code if necessary.
○ Understand what is de-interleaving.
•	Watch the video in Panopto explaining what is de-interleaving.
•	Find the code that does de-interleaving and understand it.
○ Understand de-scrambling
•	What is scrambling/ descrambling? Why is it used?
•	How can the receiver de-scramble without explicit knowledge of the scrambler initial state?
■ Which fields of the received frames are used and how?

Week 8
■ Understand the decoding (Section 2.8)
○ Will add detailed questions about the decoding later
■ Try out your 802.11a receiver with a real 802.11a access point. Can you see the received frames?
○ Read Section 8 (Interoperability)



